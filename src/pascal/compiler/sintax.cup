package pascal.compiler;

import java_cup.runtime.*;
import java.io.FileReader;
import pascal.ast.*;

parser code {:

	public Object root;

	/* Reporte de error encontrado. */
	public void report_error(String message, Object info) {
		StringBuilder m = new StringBuilder("Sintax Error");
		if (info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
			if (s.left >= 0) {
				m.append(" at line "+(s.left+1));
				if (s.right >= 0)
					m.append(", column "+(s.right+1));
			}
		}
		m.append(" : "+message);
		System.err.println(m);
	}

	/* Cuando se encuentra un error de donde el sistema no puede
		recuperarse, se lanza un error fatal. Se despliega el mensaje
		de error y se finaliza la ejecucion. */
	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		System.exit(1);
	}

	public void syntax_error(Symbol cur_token) {
		report_error("on Token "+ cur_token, cur_token);
	}

	/* Metodo main para garantizar la ejecucion del analizador
	   lexico y sintactico, ademas que se pase como parametro la tabla
	   de simbolos correspondiente. */
	public static void main(String[] args){
		try {
			parser asin = new parser(
					new Lexer( new FileReader(args[0])));
			Object result = asin.parse().value;
			System.out.println("\n*** Resultados finales ***");
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
:};


terminal  PROGRAM, BEGIN, END, AND, ARRAY, CONST, DIV, DO, ELSE,
		  FOR, FUNCTION, IF, NIL, NOT, OF, OR, PROCEDURE, RECORD, THEN, TO, DOWNTO,
		  VAR, WHILE, LEFT_PAR, RIGHT_PAR, LEFT_BRACKET, RIGHT_BRACKET,
		  SEMICOLON, COLON, COMMA, DOT, ASIGN, PLUS, MINUS,
		  DIVIDE, PRODUCT, XOR, MOD, EQUALS, NOT_EQUAL, GREATER_THAN, LESS_THAN,
		  GREATER_EQUALS, LESS_EQUAL, INTEGER, WITH,
		  ID, IN, STRING, SET, FILE, PACKED, CASE, FORWARD, REPEAT,
		  UNTIL, CHAR, LEFT_KEY, TYPE, WRITE_LN, READ_LN, BOOLEAN, INT_CONST,
		  TRUE, FALSE, CHAR_CONS, RIGHT_KEY;


non terminal PascalProgram pascalProgram;
non terminal ProgramHeading programHeading;
non terminal IdentifierList identifierList;
non terminal Block block, block1, block2, block3, block4, block5;
non terminal LabelDeclaration labelDeclaration;
non terminal ConstantDeclaration constantDeclaration;
non terminal TypeDeclaration typeDeclaration;
non terminal VariableDeclaration variableDeclaration;
non terminal VariableIdList variableidList;
non terminal Constant constant;
non terminal Type type;
non terminal SimpleType simpleType;
non terminal StructuredType structuredType;
non terminal IndexList indexList;
non terminal FieldList fieldList;
non terminal FixedPart fixedPart;
non terminal RecordField recordField;
non terminal FieldIdList fieldidList;
non terminal VariantPart variantPart;
non terminal TagField tagField;
non terminal VariantList variantList;
non terminal Variant variant;
non terminal CaseLabelList caseLabelList;
non terminal ProcAndFuncDeclaration procAndFuncDeclaration;
non terminal ProcOrFunc procOrFunc;
non terminal BlockOrForward blockOrForward;
non terminal Parameters parameters;
non terminal FormalParameterList formalParameterList;
non terminal FormalParameterSection formalParameterSection;
non terminal ParameterIdList parameteridList;
non terminal StatementList statementList;
non terminal Statement statement;
non terminal Variable variable;
non terminal SubscriptList subscriptList;
non terminal CaseList caseList;
non terminal ForList forList;
non terminal ExpressionList expressionList;
non terminal Label label;
non terminal RecordVariableList recordVariableList;
non terminal Expression expression;
non terminal RelationalOp relationalOp;
non terminal AdditiveExpression additiveExpression;
non terminal AdditiveOp additiveOp;
non terminal MultiplicativeExpression multiplicativeExpression;
non terminal MultiplicativeOp multiplicativeOp;
non terminal UnaryExpression unaryExpression;
non terminal UnaryOp unaryOp;
non terminal PrimaryExpression primaryExpression;
non terminal ElementList elementList;
non terminal Element element;
non terminal empty;

precedence left OR ;
precedence left AND ;
precedence nonassoc EQUALS, NOT_EQUAL, LESS_THAN, GREATER_THAN, LESS_EQUAL, GREATER_EQUALS ;
precedence left PLUS, MINUS ;
precedence left PRODUCT, DIVIDE ;
precedence nonassoc NOT ;
precedence left DOT, LEFT_BRACKET, RIGHT_BRACKET, LEFT_PAR, RIGHT_PAR ;
precedence right ELSE;

start with pascalProgram;

pascalProgram::=
								PROGRAM ID programHeading SEMICOLON block DOT {:
									  PascalProgram r = new PascalProgram();
									  RESULT = r;
									  :}
							;


programHeading::=
								LEFT_PAR identifierList RIGHT_PAR{:
									ProgramHeading r = new ProgramHeading();
									RESULT = r;
									  :}
							;


identifierList::=
								ID  {:
									  :}
							|
								identifierList COMMA ID  {:
									  :}
							;


block::=
								labelDeclaration SEMICOLON block1  {:
									  :}
							|
								block1 {:
									  :}
							;

block1::=
								constantDeclaration SEMICOLON block2{:
									  :}
							|
								block2 {:
									:}
							;

block2::=
								typeDeclaration SEMICOLON block3{:
									  :}
							|
								block3 {:
									:}
							;

block3::=
								variableDeclaration SEMICOLON block4{:
									  :}
							|
								block4 {:
									:}
							;

block4::=
								procAndFuncDeclaration SEMICOLON block5{:
									  :}
							|
								block5 {:
									:}
							;

block5::=
								BEGIN statementList END{:
									  :}
							;


labelDeclaration::=
								label INTEGER  {:
									:}
							|
								labelDeclaration COMMA INTEGER  {:
									:}
							;


constantDeclaration::=
							   CONST ID EQUALS constant  {:
									:}
							|
							   constantDeclaration SEMICOLON  ID EQUALS constant  {:
									:}
							;


typeDeclaration::=
							   type  ID EQUALS type  {:
									:}
							|
							   typeDeclaration SEMICOLON  ID EQUALS type  {:
									:}
							;


variableDeclaration::=
							   VAR variableidList COLON type {:

									:}
							|
							   variableDeclaration SEMICOLON variableidList COLON type  {:
									:}
							;

variableidList::=
							   ID  {:
									:}
							|
							   variableidList COMMA  ID  {:
									:}
							;

constant::=
								INTEGER {:
									:}
							|
								STRING{:
									:}
							;


type::=
								simpleType  {:
									:}
							|
								structuredType  {:
									:}
							|
								constant  {:
									:}
							;


simpleType::=
							   LEFT_PAR  identifierList RIGHT_PAR  {:
									:}
							|
							 /*  constant ... constant  {:
									:}
									| */
							   ID {:
									:}
							;


structuredType::=
								ARRAY LEFT_BRACKET indexList RIGHT_BRACKET OF type  {:
									:}
							|
								RECORD fieldList END  {:
									:}
							|
								SET OF simpleType  {:
									:}
							|
								FILE OF type  {:
									:}
							|
								PACKED structuredType  {:
									:}
							;


indexList::=
								simpleType  {:
									:}
							|
								indexList COMMA simpleType  {:
									:}
							;


fieldList::=
								fixedPart  {:
									:}
							|
								fixedPart SEMICOLON variantPart {:
									:}
							|
								variantPart {:
									:}
							;


fixedPart::=
								recordField {:
									:}
							|
								fixedPart SEMICOLON recordField {:
									:}
							;


recordField::=
								empty {:
									RESULT = null;
									:}
							|
								fieldidList COLON type   {:
									:}
							;


fieldidList::=
								ID  {:
									:}
							|
								fieldidList COMMA  ID  {:
									:}
							;


variantPart::=
								CASE tagField OF variantList {:
									:}
							;


tagField::=
								ID  {:
									:}
							|
								ID COLON ID  {:
									:}
							;


variantList::=
								variant {:
									:}
							|
								variantList SEMICOLON variant {:
									:}
							;


variant::=
								empty {:
									RESULT = null;
									:}
							|
								caseLabelList COLON LEFT_PAR fieldList RIGHT_PAR  {:
									:}
							;


caseLabelList::=
								constant  {:
									:}
							|
								caseLabelList COMMA constant  {:
									:}
							;


procAndFuncDeclaration::=
								procOrFunc  {:
									:}
							|
								procAndFuncDeclaration SEMICOLON procOrFunc {:
									:}
							;


procOrFunc::=
								PROCEDURE ID parameters blockOrForward {:
									:}
							|
								FUNCTION ID parameters COLON ID blockOrForward {:
									:}
							;


blockOrForward::=
								SEMICOLON block{:
									:}
							|
								SEMICOLON FORWARD  {:
									:}
							;


parameters::=
								LEFT_PAR formalParameterList RIGHT_PAR{:
									:}
							;


formalParameterList::=
								formalParameterSection  {:
									:}
							|
								formalParameterList SEMICOLON formalParameterSection  {:
									:}
							;


formalParameterSection::=
								parameteridList COLON ID {:
									:}
							|
								VAR parameteridList COLON ID  {:
									:}
							|
								PROCEDURE ID parameters {:
									:}
							|
								FUNCTION ID parameters COLON ID {:
									:}
							;


parameteridList::=
								ID  {:
									:}
							|
								parameteridList COMMA ID  {:
									:}
							;


statementList::=
								statement  {:
										:}
							|
								statementList SEMICOLON statement  {:
									:}
							;


statement::=
								IF expression THEN statement ELSE statement  {:
									:}
							|
								ID LEFT_PAR expressionList RIGHT_PAR{:
									:}
							|
								WRITE_LN LEFT_PAR expressionList RIGHT_PAR{:
									:}
							|
								READ_LN LEFT_PAR expressionList RIGHT_PAR{:
									:}
							|
								REPEAT statementList UNTIL expression {:
									:}
							|
								FOR ID ASIGN forList DO statement  {:
									:}
							|
								WITH recordVariableList DO statement  {:
									:}
							|
								CASE expression OF caseList END {:
									:}
							|
								WHILE expression DO statement  {:
									:}
							|
								IF expression THEN statement {:
									:}
							|
								variable expression SEMICOLON {:
									:}
							|
								BEGIN statementList END  {:
									:}
							|
								label COLON statement  {:
									:}
							|
								ID  {:
									:}
							|
								empty  {:
									RESULT = null;
									:}
							;


variable::=
								ID LEFT_BRACKET subscriptList RIGHT_BRACKET  {:
									:}
							|
								ID DOT ID  {:
									:}
							|
								ID ASIGN {:
									:}
							;


subscriptList::=
								expression  {:
									:}
							|
								subscriptList COMMA expression  {:
									:}
							;


caseList::=
								caseLabelList:cll COLON:s statement:stm  {:
									CaseList r = new CaseList(cll, (String) s, stm);
									RESULT = r;
									:}
							|
								caseList:cl SEMICOLON:sc caseLabelList:cll COLON:c statement:stm  {:
									CaseList r = new CaseList(cll, (String) sc, (String) c, stm, cl);
									RESULT = r;
									:}
							;


forList::=
								expression:exl TO:s expression:exr  {:
									ForList r = new ForList(exl, (String) s, exr);
									RESULT = r;
									:}
							|
								expression:exl DOWNTO:s expression:exr  {:
									ForList r = new ForList(exl, (String) s, exr);
									RESULT = r;
									:}
							;


expressionList::=
								expression:ex  {:
									ExpressionList r = new ExpressionList(ex);
									RESULT = r;
									:}
							|
								expressionList:el COMMA:s expression:ex  {:
									ExpressionList r = new ExpressionList(el, (String) s, ex);
									RESULT = r;
									:}
							;


label::=
								INTEGER:s{:
									Label r = new Label((String) s);
									RESULT = r;
									:}
							;


recordVariableList::=
								variable:v  {:
									RecordVariableList r = new RecordVariableList(v);
									RESULT = r;
									:}
							|
								recordVariableList:rvl COMMA:s variable:v  {:
									RecordVariableList r = new RecordVariableList(rvl, (String) s, v);
									RESULT = r;
									:}
							;


expression::=
								expression:ex relationalOp:ro additiveExpression:ae {:
									Expression r = new Expression(ex, ro, ae);
									RESULT = r;
									:}
							|
								additiveExpression:ae {:
									Expression r = new Expression(ae);
									RESULT = r;
									:}
							|
								INT_CONST:s {:
									Expression r = new Expression((String) s);
									RESULT = r;
									:}
							|
								error {:
									System.out.println("expression error");
									:}
							;


relationalOp::=
								LESS_THAN:s  {:
									RelationalOp r = new RelationalOp((String) s);
									RESULT = r;
									:}
							|
								LESS_EQUAL:s {:
									RelationalOp r = new RelationalOp((String) s);
									RESULT = r;
									:}
							|
								EQUALS:s {:
									RelationalOp r = new RelationalOp((String) s);
									RESULT = r;
									:}
							|
								NOT_EQUAL:s {:
									RelationalOp r = new RelationalOp((String) s);
									RESULT = r;
									:}
							|
								GREATER_EQUALS:s {:
									RelationalOp r = new RelationalOp((String) s);
									RESULT = r;
									:}
							|
								GREATER_THAN:s {:
									RelationalOp r = new RelationalOp((String) s);
									RESULT = r;
									:}
							;


additiveExpression::=
								additiveExpression:ae additiveOp:ao multiplicativeExpression:me {:
									AdditiveExpression r = new AdditiveExpression(ae, ao, me);
									RESULT = r;
									:}
							|
								multiplicativeExpression:me  {:
									AdditiveExpression r = new AdditiveExpression(me);
									RESULT = r;
									:}
							;


additiveOp::=
								PLUS:s {:
									AdditiveOp r = new AdditiveOp((String) s);
									RESULT = r;
									:}
						   |
								MINUS:s {:
									AdditiveOp r = new AdditiveOp((String) s);
									RESULT = r;
									:}
						   |
								OR:s {:
									AdditiveOp r = new AdditiveOp((String) s);
									RESULT = r;
									:}
							;


multiplicativeExpression::=
								multiplicativeExpression:me multiplicativeOp:mo unaryExpression:ue {:
									MultiplicativeExpression r = new MultiplicativeExpression(me, mo, ue);
									RESULT = r;
									:}
							|
								unaryExpression:ue  {:
									MultiplicativeExpression r = new MultiplicativeExpression(ue);
									RESULT = r;
									:}
							;


multiplicativeOp::=
								PRODUCT:o {:
									MultiplicativeOp r = new MultiplicativeOp((String) o);
									RESULT = r;
									:}
							|
								DIVIDE:o {:
									MultiplicativeOp r = new MultiplicativeOp((String) o);
									RESULT = r;
									:}
							|
								DIV:o {:
									MultiplicativeOp r = new MultiplicativeOp((String) o);
									RESULT = r;
									:}
							|
								MOD:o {:
									MultiplicativeOp r = new MultiplicativeOp((String) o);
									RESULT = r;
									:}
							|
								AND:o {:
									MultiplicativeOp r = new MultiplicativeOp((String) o);
									RESULT = r;
									:}
							|
								IN:o {:
									MultiplicativeOp r = new MultiplicativeOp((String) o);
									RESULT = r;
									:}
							;


unaryExpression::=
								unaryOp:uo unaryExpression:ue  {:
									UnaryExpression r = new UnaryExpression(uo, ue);
									RESULT = r;
									:}
							|
								primaryExpression:pe  {:
									UnaryExpression r = new UnaryExpression(pe);
									RESULT = r;
									:}
							;


unaryOp::=
								PLUS:u {:
									UnaryOp r = new UnaryOp((String) u);
									RESULT = r;
									:}
							|
								MINUS:u {:
									UnaryOp r = new UnaryOp((String) u);
									RESULT = r;
									:}
							|
								NOT:u {:
									UnaryOp r = new UnaryOp((String) u);
									RESULT = r;
									:}
							;


primaryExpression::=
								ID:tid LEFT_PAR expressionList:el RIGHT_PAR {:
									PrimaryExpression r = new PrimaryExpression(tid, el);
									RESULT = r;
									:}
							|
								LEFT_BRACKET elementList:elm RIGHT_BRACKET {:
									PrimaryExpression r = new PrimaryExpression(elm);
									RESULT = r;
									:}
							|
								LEFT_PAR expression:exp RIGHT_PAR  {:
									PrimaryExpression r = new PrimaryExpression(exp);
									RESULT = r;
									:}
							|
								NIL:nil  {:
									PrimaryExpression r = new PrimaryExpression((String) nil);
									RESULT = r;
									:}
							|
								INTEGER:integer  {:
									PrimaryExpression r = new PrimaryExpression((String) integer);
									RESULT = r;
									:}
							|
								STRING:string  {:
									PrimaryExpression r = new PrimaryExpression((String) string);
									RESULT = r;
									:}
							|
								variable:var  {:
									PrimaryExpression r = new PrimaryExpression(var);
									RESULT = r;
									:}
							;


elementList::=
								element:e  {:
									ElementList r = new ElementList(e);
									RESULT = r;
									:}
							|
								elementList:el COMMA element:e  {:
									ElementList r = new ElementList(e, el);
									RESULT = r;
									:}
							;


element::=
								expression:e  {:
									Element r = new Element(e);
									RESULT = r;
									:}
							|
								element:el expression:ex  {:
									Element r = new Element(el, ex);
									RESULT = r;
									:}
							;



empty::=
							;