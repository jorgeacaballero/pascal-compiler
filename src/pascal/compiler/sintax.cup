package pascal.compiler;

import java_cup.runtime.*;
import java.io.FileReader;
import pascal.ast.*;

parser code {:

	public Object root;

	/* Reporte de error encontrado. */
	public void report_error(String message, Object info) {
		StringBuilder m = new StringBuilder("Sintax Error");
		if (info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
			if (s.left >= 0) {
				m.append(" at line "+(s.left+1));
				if (s.right >= 0)
					m.append(", column "+(s.right+1));
			}
		}
		m.append(" : "+message);
		System.err.println(m);
	}

	/* Cuando se encuentra un error de donde el sistema no puede
		recuperarse, se lanza un error fatal. Se despliega el mensaje
		de error y se finaliza la ejecucion. */
	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		System.exit(1);
	}

	public void syntax_error(Symbol cur_token) {
		report_error("on Token "+ cur_token, cur_token);
	}

	/* Metodo main para garantizar la ejecucion del analizador
	   lexico y sintactico, ademas que se pase como parametro la tabla
	   de simbolos correspondiente. */
	public static void main(String[] args){
		try {
			parser asin = new parser(
					new Lexer( new FileReader(args[0])));
			Object result = asin.parse().value;
			System.out.println("\n*** Resultados finales ***");
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
:};


terminal  PROGRAM, BEGIN, END, AND, ARRAY, CONST, DIV, DO, ELSE,
		  FOR, FUNCTION, IF, NIL, NOT, OF, OR, PROCEDURE, RECORD, THEN, TO, DOWNTO,
		  VAR, WHILE, LEFT_PAR, RIGHT_PAR, LEFT_BRACKET, RIGHT_BRACKET,
		  SEMICOLON, COLON, COMMA, DOT, ASIGN, PLUS, MINUS,
		  DIVIDE, PRODUCT, XOR, MOD, EQUALS, NOT_EQUAL, GREATER_THAN, LESS_THAN,
		  GREATER_EQUALS, LESS_EQUAL, INTEGER, WITH,
		  ID, IN, STRING, SET, FILE, PACKED, CASE, FORWARD, REPEAT,
		  UNTIL, CHAR, LEFT_KEY, TYPE, WRITE_LN, READ_LN, BOOLEAN, INT_CONST,
		  TRUE, FALSE, CHAR_CONS, RIGHT_KEY;


non terminal PascalProgram pascalProgram;
non terminal ProgramHeading programHeading;
non terminal IdentifierList identifierList;
non terminal Block block, block1, block2, block3, block4, block5;
non terminal LabelDeclaration labelDeclaration;
non terminal ConstantDeclaration constantDeclaration;
non terminal TypeDeclaration typeDeclaration;
non terminal VariableDeclaration variableDeclaration;
non terminal VariableIdList variableidList;
non terminal Constant constant;
non terminal Type type;
non terminal SimpleType simpleType;
non terminal StructuredType structuredType;
non terminal IndexList indexList;
non terminal FieldList fieldList;
non terminal FixedPart fixedPart;
non terminal RecordField recordField;
non terminal FieldList fieldidList;
non terminal VariantPart variantPart;
non terminal TagField tagField;
non terminal VariantList variantList;
non terminal Variant variant;
non terminal CaseLabelList caseLabelList;
non terminal ProcAndFuncDeclaration procAndFuncDeclaration;
non terminal ProcOrFunc procOrFunc;
non terminal BlockOrForward blockOrForward;
non terminal Parameters parameters;
non terminal FormalParameterList formalParameterList;
non terminal FormalParameterSection formalParameterSection;
non terminal ParameterIdList parameteridList;
non terminal StatementList statementList;
non terminal Statement statement;
non terminal Variable variable;
non terminal SubscriptList subscriptList;
non terminal CaseList caseList;
non terminal ForList forList;
non terminal ExpressionList expressionList;
non terminal Label label;
non terminal RecordVariableList recordVariableList;
non terminal Expression expression;
non terminal RelationalOp relationalOp;
non terminal AdditiveExpression additiveExpression;
non terminal AdditiveOp additiveOp;
non terminal MultiplicativeExpression multiplicativeExpression;
non terminal MultiplicativeOp multiplicativeOp;
non terminal UnaryExpression unaryExpression;
non terminal UnaryOp unaryOp;
non terminal PrimaryExpression primaryExpression;
non terminal ElementList elementList;
non terminal Element element;
non terminal ConstId constid, typeid, procid, fieldid, varid;
non terminal empty;

precedence left OR ;
precedence left AND ;
precedence nonassoc EQUALS, NOT_EQUAL, LESS_THAN, GREATER_THAN, LESS_EQUAL, GREATER_EQUALS ;
precedence left PLUS, MINUS ;
precedence left PRODUCT, DIVIDE ;
precedence nonassoc NOT ;
precedence left DOT, LEFT_BRACKET, RIGHT_BRACKET, LEFT_PAR, RIGHT_PAR ;
precedence right ELSE;

start with pascalProgram;

pascalProgram::=
								PROGRAM ID programHeading SEMICOLON block DOT {:
									  PascalProgram r = new PascalProgram();
									  RESULT = r;
									  :}
							;


programHeading::=
								LEFT_PAR identifierList RIGHT_PAR{:
									ProgramHeading r = new ProgramHeading();
									RESULT = r;
									  :}
							;


identifierList::=
								ID  {:
									  :}
							|
								identifierList COMMA ID  {:
									  :}
							;


block::=
								labelDeclaration SEMICOLON block1  {:
									  :}
							|
								block1 {:
									  :}
							;

block1::=
								constantDeclaration SEMICOLON block2{:
									  :}
							|
								block2 {:
									:}
							;

block2::=
								typeDeclaration SEMICOLON block3{:
									  :}
							|
								block3 {:
									:}
							;

block3::=
								variableDeclaration SEMICOLON block4{:
									  :}
							|
								block4 {:
									:}
							;

block4::=
								procAndFuncDeclaration SEMICOLON block5{:
									  :}
							|
								block5 {:
									:}
							;

block5::=
								BEGIN statementList END{:
									  :}
							;


labelDeclaration::=
								label INTEGER  {:
									:}
							|
								labelDeclaration COMMA INTEGER  {:
									:}
							;


constantDeclaration::=
							   CONST ID EQUALS constant  {:
									:}
							|
							   constantDeclaration SEMICOLON  ID EQUALS constant  {:
									:}
							;


typeDeclaration::=
							   type  ID EQUALS type  {:
									:}
							|
							   typeDeclaration SEMICOLON  ID EQUALS type  {:
									:}
							;


variableDeclaration::=
							   VAR variableidList COLON type {:

									:}
							|
							   variableDeclaration SEMICOLON variableidList COLON type  {:
									:}
							;

variableidList::=
							   ID  {:
									:}
							|
							   variableidList COMMA  ID  {:
									:}
							;

constant::=
								INTEGER {:
									:}
							|
								STRING{:
									:}
							;


type::=
								simpleType  {:
									:}
							|
								structuredType  {:
									:}
							|
								constant  {:
									:}
							;


simpleType::=
							   LEFT_PAR  identifierList RIGHT_PAR  {:
									:}
							|
							 /*  constant ... constant  {:
									:}
									| */
							   typeid {:
									:}
							;


structuredType::=
								ARRAY LEFT_BRACKET indexList RIGHT_BRACKET OF type  {:
									:}
							|
								RECORD fieldList END  {:
									:}
							|
								SET OF simpleType  {:
									:}
							|
								FILE OF type  {:
									:}
							|
								PACKED structuredType  {:
									:}
							;


indexList::=
								simpleType  {:
									:}
							|
								indexList COMMA simpleType  {:
									:}
							;


fieldList::=
								fixedPart  {:
									:}
							|
								fixedPart SEMICOLON variantPart {:
									:}
							|
								variantPart {:
									:}
							;


fixedPart::=
								recordField {:
									:}
							|
								fixedPart SEMICOLON recordField {:
									:}
							;


recordField::=
								empty {:
									RESULT = null;
									:}
							|
								fieldidList COLON type   {:
									:}
							;


fieldidList::=
								ID  {:
									:}
							|
								fieldidList COMMA  ID  {:
									:}
							;


variantPart::=
								CASE tagField OF variantList {:
									:}
							;


tagField::=
								typeid  {:
									:}
							|
								ID COLON typeid  {:
									:}
							;


variantList::=
								variant {:
									:}
							|
								variantList SEMICOLON variant {:
									:}
							;


variant::=
								empty {:
									RESULT = null;
									:}
							|
								caseLabelList COLON LEFT_PAR fieldList RIGHT_PAR  {:
									:}
							;


caseLabelList::=
								constant  {:
									:}
							|
								caseLabelList COMMA constant  {:
									:}
							;


procAndFuncDeclaration::=
								procOrFunc  {:
									:}
							|
								procAndFuncDeclaration SEMICOLON procOrFunc {:
									:}
							;


procOrFunc::=
								PROCEDURE ID parameters blockOrForward {:
									:}
							|
								FUNCTION ID parameters COLON typeid blockOrForward {:
									:}
							;


blockOrForward::=
								SEMICOLON block{:
									:}
							|
								SEMICOLON FORWARD  {:
									:}
							;


parameters::=
								LEFT_PAR formalParameterList RIGHT_PAR{:
									:}
							;


formalParameterList::=
								formalParameterSection  {:
									:}
							|
								formalParameterList SEMICOLON formalParameterSection  {:
									:}
							;


formalParameterSection::=
								parameteridList COLON typeid {:
									:}
							|
								VAR parameteridList COLON typeid  {:
									:}
							|
								PROCEDURE ID parameters {:
									:}
							|
								FUNCTION ID parameters COLON typeid {:
									:}
							;


parameteridList::=
								ID  {:
									:}
							|
								parameteridList COMMA ID  {:
									:}
							;


statementList::=
								statement  {:
										:}
							|
								statementList SEMICOLON statement  {:
									:}
							;


statement::=
								IF expression THEN statement ELSE statement  {:
									:}
							|
								procid LEFT_PAR expressionList RIGHT_PAR{:
									:}
							|
								WRITE_LN LEFT_PAR expressionList RIGHT_PAR{:
									:}
							|
								READ_LN LEFT_PAR expressionList RIGHT_PAR{:
									:}
							|							
								REPEAT statementList UNTIL expression {:
									:}
							|
								FOR varid ASIGN forList DO statement  {:
									:}
							|
								WITH recordVariableList DO statement  {:
									:}
							|
								CASE expression OF caseList END {:
									:}
							|
								WHILE expression DO statement  {:
									:}
							|
								IF expression THEN statement {:
									:}
							|
								variable expression SEMICOLON {:
									:}
							|
								BEGIN statementList END  {:
									:}
							|
								label COLON statement  {:
									:}
							|
								procid  {:
									:}
							|
								empty  {:
									RESULT = null;
									:}
							;


variable::=
								ID LEFT_BRACKET subscriptList RIGHT_BRACKET  {:
									:}
							|
								ID DOT fieldid  {:
									:}
							|
								ID ASIGN {:
									:}
							;


subscriptList::=
								expression  {:
									:}
							|
								subscriptList COMMA expression  {:
									:}
							;


caseList::=
								caseLabelList COLON statement  {:
									:}
							|
								caseList SEMICOLON caseLabelList COLON statement  {:
									:}
							;


forList::=
								expression TO expression  {:
									:}
							|
								expression DOWNTO expression  {:
									:}
							;


expressionList::=
								expression  {:
									:}
							|
								expressionList COMMA expression  {:
									:}
							;


label::=
								INTEGER{:
									:}
							;


recordVariableList::=
								variable  {:
									:}
							|
								recordVariableList COMMA variable  {:
									:}
							;


expression::=
								expression relationalOp additiveExpression {:
									:}
							|
								additiveExpression  {:
									:}
							|
								INT_CONST {:
									:}
							|
								error {:
									System.out.println("expression error");
									:}
							;


relationalOp::=
								LESS_THAN  {:
									:}
							|
								LESS_EQUAL {:
									:}
							|
								EQUALS {:
									:}
							|
								NOT_EQUAL {:
									:}
							|
								GREATER_EQUALS {:
									:}
							|
								GREATER_THAN {:
										:}
							;


additiveExpression::=
								additiveExpression additiveOp multiplicativeExpression {:
									:}
							|
								multiplicativeExpression  {:
									:}
							;


additiveOp::=
								PLUS {:
									:}
						   |
								MINUS {:
									:}
						   |
								OR {:
									:}
							;


multiplicativeExpression::=
								multiplicativeExpression multiplicativeOp unaryExpression {:
									:}
							|
								unaryExpression  {:
									:}
							;


multiplicativeOp::=
								PRODUCT {:
									:}
							|
								DIVIDE {:
									:}
							|
								DIV  {:
									:}
							|
								MOD {:
									:}
							|
								AND
							|
								IN {:
									:}
							;


unaryExpression::=
								unaryOp unaryExpression  {:
									:}
							|
								primaryExpression  {:
									:}
							;


unaryOp::=
								PLUS {:
									:}
							|
								MINUS {:
									:}
							|
								NOT {:
									:}
							;


primaryExpression::=
								typeid LEFT_PAR expressionList RIGHT_PAR {:
									:}
							|
								LEFT_BRACKET elementList RIGHT_BRACKET {:
									:}
							|
								LEFT_PAR expression RIGHT_PAR  {:
									:}
							|
								NIL  {:
									:}
							|
								INTEGER  {:
									:}
							|
								STRING  {:
									:}
							|
								variable  {:
									:}
							;


elementList::=
								element  {:
									:}
							|
								elementList COMMA element  {:
									:}
							;


element::=
								expression  {:
									:}
							|
								element expression  {:
									:}
							;


constid::=
								ID  {:
									:}
							;


typeid::=
								ID  {:
									:}
							;


procid::=
								ID  {:
									:}
							;


fieldid::=
								ID   {:
									:}
							;


varid::=
								ID  {:
									:}
							;


empty::=
							;