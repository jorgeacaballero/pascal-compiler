package pascal.compiler;

import java_cup.runtime.*;
import java.io.FileReader;
import pascal.ast.*;

parser code {:

	/* Reporte de error encontrado. */
	public void report_error(String message, Object info) {
		StringBuilder m = new StringBuilder("Sintax Error");
		if (info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
			if (s.left >= 0) {
				m.append(" at line "+(s.left+1));
				if (s.right >= 0)
					m.append(", column "+(s.right+1));
			}
		}
		m.append(" : "+message);
		System.err.println(m);
	}

	/* Cuando se encuentra un error de donde el sistema no puede
		recuperarse, se lanza un error fatal. Se despliega el mensaje
		de error y se finaliza la ejecucion. */
	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		System.exit(1);
	}

	/* Metodo main para garantizar la ejecucion del analizador
	   lexico y sintactico, ademas que se pase como parametro la tabla
	   de simbolos correspondiente. */
	public static void main(String[] args){
		try {
			AnalizadorSintactico asin = new AnalizadorSintactico(
					new Lexer( new FileReader(args[0])));
			Object result = asin.parse().value;
			System.out.println("\n*** Resultados finales ***");
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
:};


terminal  PROGRAM, BEGIN, WRITE_LN, END, AND, ARRAY, CONST, DIV, DO, ELSE,
		  FOR, FUNCTION, IF, NIL, NOT, OF, OR, PROCEDURE, RECORD, THEN, TO, DOWNTO,
		  TYPE, VAR, WHILE, LEFT_PAR, RIGHT_PAR, LEFT_BRACKET, RIGHT_BRACKET,
		  LEFT_KEY, RIGHT_KEY, SEMICOLON, COLON, COMMA, DOT, ASIGN, PLUS, MINUS,
		  DIVIDE, PRODUCT, XOR, MOD, EQUALS, NOT_EQUAL, GREATER_THAN, LESS_THAN,
		  GREATER_EQUALS, LESS_EQUAL, BOOLEAN, TRUE, FALSE, CHAR, INTEGER,
		  CHAR_CONS, INT_CONST, ID, IN, STRING, SET, FILE, PACKED, CASE, FORWARD, REPEAT,
		  UNTIL;


non terminal pascalProgram, programHeading, identifierList, block, labelDeclaration,
			 constantDeclaration, typeDeclaration, variableDeclaration, variableidList,
			 constant, type, simpleType, structuredType, indexList, fieldList, fixedPart,
			 recordField, fieldidList, variantPart, tagField, variantList, variant,
			 caseLabelList, procAndFuncDeclaration, procOrFunc, blockOrForward, parameters,
			 formalParameterList, formalParameterSection, parameteridList, statementList,
			 statement, variable, subscriptList, caseList, forList, expressionList, label,
			 recordVariableList, expression, relationalOp, additiveExpression, additiveOp,
			 multiplicativeExpression, multiplicativeOp, unaryExpression, unaryOp,
			 primaryExpression, elementList, element, constid, typeid, funcid, procid,
			 fieldid, varid, empty, block1, block2, block3, block4, block5;

precedence left OR ;
precedence left AND ;
precedence nonassoc EQUALS, NOT_EQUAL, LESS_THAN, GREATER_THAN, LESS_EQUAL, GREATER_EQUALS ;
precedence left PLUS, MINUS ;
precedence left PRODUCT, DIVIDE ;
precedence nonassoc NOT ;
precedence left DOT, LEFT_BRACKET, RIGHT_BRACKET ;

start with pascalProgram;



pascalProgram::=
								PROGRAM ID programHeading SEMICOLON block DOT {:
									  :}
							;


programHeading::=
								LEFT_PAR identifierList RIGHT_PAR{:
									  :}
							;


identifierList::=
								ID  {:
									  :}
							|
								identifierList COMMA ID  {:
									  :}
							;


block::= 
								labelDeclaration SEMICOLON block1  {:
									  :}
							| 
								block1 {:
									  :}	
							;						

block1::=
								constantDeclaration SEMICOLON block2{:
									  :}
							|
								block2 {:
									:}
							;

block2::=
								typeDeclaration SEMICOLON block3{:
									  :}
							|
								block3 {:
									:}
							;

block3::=
								variableDeclaration SEMICOLON block4{:
									  :}
							|
								block4 {:
									:}
							;

block4::=
								procAndFuncDeclaration SEMICOLON block5{:
									  :}
							|
								block5 {:
									:}
							;

block5::=
								BEGIN statementList END{:
									  :}
							;


labelDeclaration::=
								label INTEGER  {:
									:}
							|
								labelDeclaration COMMA INTEGER  {:
									:}
							;


constantDeclaration::=
							   CONST  ID EQUALS constant  {:
									:}
							|
							   constantDeclaration SEMICOLON  ID EQUALS constant  {:
									:}
							;


typeDeclaration::=
							   type  ID EQUALS type  {:
									:}
							|
							   typeDeclaration SEMICOLON  ID EQUALS type  {:
									:}
							;


variableDeclaration::=
							   VAR variableidList COLON type  {:
									:}
							|
							   variableDeclaration SEMICOLON variableidList COLON type  {:
									:}
							;


variableidList::=
							   ID  {:
									:}
							|
							   variableidList COMMA  ID  {:
									:}
							;

constant::=
								INTEGER {:
									:}
							|
								STRING{:
									:}
							|
								constid  {:
									:}
							;


type::=
								simpleType  {:
									:}
							|
								structuredType  {:
									:}
							|
								XOR typeid  {:
									:}
							;


simpleType::=
							   LEFT_PAR  identifierList RIGHT_PAR  {:
									:}
							|
							 /*  constant ... constant  {:
									:}
									| */
							   typeid {:
									:}
							;


structuredType::=
								ARRAY LEFT_BRACKET indexList RIGHT_BRACKET OF type  {:
									:}
							|
								RECORD fieldList END  {:
									:}
							|
								SET OF simpleType  {:
									:}
							|
								FILE OF type  {:
									:}
							|
								PACKED structuredType  {:
									:}
							;


indexList::=
								simpleType  {:
									:}
							|
								indexList COMMA simpleType  {:
									:}
							;


fieldList::=
								fixedPart  {:
									:}
							|
								fixedPart SEMICOLON variantPart {:
									:}
							|
								variantPart {:
									:}
							;


fixedPart::=
								recordField {:
									:}
							|
								fixedPart SEMICOLON recordField {:
									:}
							;


recordField::=
								empty {:
									:}
							|
								fieldidList COLON type   {:
									:}
							;


fieldidList::=
								ID  {:
									:}
							|
								fieldidList COMMA  ID  {:
									:}
							;


variantPart::=
								CASE tagField OF variantList {:
									:}
							;


tagField::=
								typeid  {:
									:}
							|
								ID COLON typeid  {:
									:}
							;


variantList::=
								variant {:
									:}
							|
								variantList SEMICOLON variant {:
									:}
							;


variant::=
								empty {:
									:}
							|
								caseLabelList COLON LEFT_PAR fieldList RIGHT_PAR  {:
									:}
							;


caseLabelList::=
								constant  {:
									:}
							|
								caseLabelList COMMA constant  {:
									:}
							;


procAndFuncDeclaration::=
								procOrFunc  {:
									:}
							|
								procAndFuncDeclaration SEMICOLON procOrFunc {:
									:}
							;


procOrFunc::=
								PROCEDURE ID parameters blockOrForward {:
									:}
							|
								FUNCTION ID parameters COLON typeid blockOrForward {:
									:}
							;


blockOrForward::=
								SEMICOLON block{:
									:}
							|
								SEMICOLON FORWARD  {:
									:}
							;


parameters::=
								LEFT_PAR formalParameterList RIGHT_PAR{:
									:}
							;


formalParameterList::=
								formalParameterSection  {:
									:}
							|
								formalParameterList SEMICOLON formalParameterSection  {:
									:}
							;


formalParameterSection::=
								parameteridList COLON typeid {:
									:}
							|
								VAR parameteridList COLON typeid  {:
									:}
							|
								PROCEDURE ID parameters {:
									:}
							|
								FUNCTION ID parameters COLON typeid {:
									:}
							;


parameteridList::=
								ID  {:
									:}
							|
								parameteridList COMMA ID  {:
									:}
							;


statementList::=
								statement  {:
										:}
							|
								statementList SEMICOLON statement  {:
									:}
							;


statement::=
								empty  {:
									:}
							|
								variable ASIGN expression  {:
									:}
							|
								BEGIN statementList END  {:
									:}
							|
								IF expression THEN statement {:
									:}
							|
								IF expression THEN statement ELSE statement  {:
									:}
							|
								WHILE expression DO statement  {:
									:}
							|
								REPEAT statementList UNTIL expression {:
									:}
							|
								FOR varid ASIGN forList DO statement  {:
									:}
							|
								procid  {:
									:}
							|
								procid LEFT_PAR expressionList RIGHT_PAR{:
									:}
							|
								label COLON statement  {:
									:}
							;


variable::=
								ID  {:
									:}
							|
								variable LEFT_BRACKET subscriptList RIGHT_BRACKET  {:
									:}
							|
								variable DOT fieldid  {:
									:}
							|
								variable XOR  {:
									:}
							;


subscriptList::=
								expression  {:
									:}
							|
								subscriptList COMMA expression  {:
									:}
							;


caseList::=
								caseLabelList COLON statement  {:
									:}
							|
								caseList SEMICOLON caseLabelList COLON statement  {:
									:}
							;


forList::=
								expression TO expression  {:
									:}
							|
								expression DOWNTO expression  {:
									:}
							;


expressionList::=
								expression  {:
									:}
							|
								expressionList COMMA expression  {:
									:}
							;


label::=
								INTEGER{:
									:}
							;


recordVariableList::=
								variable  {:
									:}
							|
								recordVariableList COMMA variable  {:
									:}
							;


expression::=
								expression relationalOp additiveExpression {:
									:}
							|
								additiveExpression  {:
									:}
							;


relationalOp::=
								LESS_THAN  {:
									:}
							|
								LESS_EQUAL {:
									:}
							|
								EQUALS {:
									:}
							|
								NOT_EQUAL {:
									:}
							|
								GREATER_EQUALS {:
									:}
							|
								GREATER_THAN {:
										:}
							;


additiveExpression::=
								additiveExpression additiveOp multiplicativeExpression {:
									:}
							|
								multiplicativeExpression  {:
									:}
							;


additiveOp::=
								PLUS {:
									:}
						   |
								MINUS {:
									:}
						   |
								OR {:
									:}
							;


multiplicativeExpression::=
								multiplicativeExpression multiplicativeOp unaryExpression {:
									:}
							|
								unaryExpression  {:
									:}
							;


multiplicativeOp::=
								PRODUCT {:
									:}
							|
								DIVIDE {:
									:}
							|
								DIV  {:
									:}
							|
								MOD {:
									:}
							|
								AND
							|
								IN {: //putos no se les olvide meter esta mierda en el cup ***************************************************
									:}
							;


unaryExpression::=
								unaryOp unaryExpression  {:
									:}
							|
								primaryExpression  {:
									:}
							;


unaryOp::=
								PLUS {:
									:}
							|
								MINUS {:
									:}
							|
								NOT {:
									:}
							;


primaryExpression::=
								variable  {:
									:}
							|
								INTEGER  {:
									:}
							|
								STRING  {:
									:}
							|
								NIL  {:
									:}
							|
								funcid LEFT_PAR expressionList RIGHT_PAR {:
									:}
							|
								LEFT_BRACKET elementList RIGHT_BRACKET {:
									:}
							|
								LEFT_PAR expression RIGHT_PAR  {:
									:}
							;


elementList::=
								empty  {:
									:}
							|
								element  {:
									:}
							|
								elementList COMMA element  {:
									:}
							;


element::=
								expression  {:
									:}
							|
								element expression  {:
									:}
							;


constid::=
								ID  {:
									:}
							;


typeid::=
								ID  {:
									:}
							;


funcid::=
								ID  {:
									:}
							;


procid::=
								ID  {:
									:}
							;


fieldid::=
								ID   {:
									:}
							;


varid::=
								ID  {:
									:}
							;


empty::=
								{:
								:}
							;