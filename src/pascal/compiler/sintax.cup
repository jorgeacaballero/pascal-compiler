package pascal.compiler;

import java_cup.runtime.*;
import java.io.FileReader;
import pascal.ast.*;

parser code {:

	public Object root;

	/* Reporte de error encontrado. */
	public void report_error(String message, Object info) {
		StringBuilder m = new StringBuilder("Sintax Error");
		if (info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
			if (s.left >= 0) {
				m.append(" at line "+(s.left+1));
				if (s.right >= 0)
					m.append(", column "+(s.right+1));
			}
		}
		m.append(" : "+message);
		System.err.println(m);
	}

	/* Cuando se encuentra un error de donde el sistema no puede
		recuperarse, se lanza un error fatal. Se despliega el mensaje
		de error y se finaliza la ejecucion. */
	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		System.exit(1);
	}

	public void syntax_error(Symbol cur_token) {
		report_error("on Token "+ cur_token, cur_token);
	}

	/* Metodo main para garantizar la ejecucion del analizador
	   lexico y sintactico, ademas que se pase como parametro la tabla
	   de simbolos correspondiente. */
	public static void main(String[] args){
		try {
			parser asin = new parser(
					new Lexer( new FileReader(args[0])));
			Object result = asin.parse().value;
			System.out.println("\n*** Resultados finales ***");
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
:};


terminal  PROGRAM, BEGIN, END, AND, ARRAY, CONST, DIV, DO, ELSE,
		  FOR, FUNCTION, IF, NIL, NOT, OF, OR, PROCEDURE, RECORD, THEN, TO, DOWNTO,
		  VAR, WHILE, LEFT_PAR, RIGHT_PAR, LEFT_BRACKET, RIGHT_BRACKET,
		  SEMICOLON, COLON, COMMA, DOT, ASIGN, PLUS, MINUS,
		  DIVIDE, PRODUCT, XOR, MOD, EQUALS, NOT_EQUAL, GREATER_THAN, LESS_THAN,
		  GREATER_EQUALS, LESS_EQUAL, INTEGER, WITH,
		  ID, IN, STRING, SET, FILE, PACKED, CASE, FORWARD, REPEAT,
		  UNTIL;


terminal CHAR, LEFT_KEY, TYPE, WRITE_LN, BOOLEAN, INT_CONST, TRUE, FALSE, CHAR_CONS, RIGHT_KEY;


non terminal pascalProgram, programHeading, identifierList, block, labelDeclaration,
			 constantDeclaration, typeDeclaration, variableDeclaration, variableidList,
			 constant, type, simpleType, structuredType, indexList, fieldList, fixedPart,
			 recordField, fieldidList, variantPart, tagField, variantList, variant,
			 caseLabelList, procAndFuncDeclaration, procOrFunc, blockOrForward, parameters,
			 formalParameterList, formalParameterSection, parameteridList, statementList,
			 statement, variable, subscriptList, caseList, forList, expressionList, label,
			 recordVariableList, expression, relationalOp, additiveExpression, additiveOp,
			 multiplicativeExpression, multiplicativeOp, unaryExpression, unaryOp,
			 primaryExpression, elementList, element, constid, typeid, procid,
			 fieldid, varid, empty, block1, block2, block3, block4, block5;

precedence left OR ;
precedence left AND ;
precedence nonassoc EQUALS, NOT_EQUAL, LESS_THAN, GREATER_THAN, LESS_EQUAL, GREATER_EQUALS ;
precedence left PLUS, MINUS ;
precedence left PRODUCT, DIVIDE ;
precedence nonassoc NOT ;
precedence left DOT, LEFT_BRACKET, RIGHT_BRACKET, LEFT_PAR, RIGHT_PAR ;
precedence right ELSE;

start with pascalProgram;



pascalProgram::=
								PROGRAM ID programHeading SEMICOLON block DOT {:
									  :}
							;


programHeading::=
								LEFT_PAR identifierList RIGHT_PAR{:
									  :}
							;


identifierList::=
								ID  {:
									  :}
							|
								identifierList COMMA ID  {:
									  :}
							;


block::=
								labelDeclaration SEMICOLON block1  {:
									  :}
							|
								block1 {:
									  :}
							;

block1::=
								constantDeclaration SEMICOLON block2{:
									  :}
							|
								block2 {:
									:}
							;

block2::=
								typeDeclaration SEMICOLON block3{:
									  :}
							|
								block3 {:
									:}
							;

block3::=
								variableDeclaration SEMICOLON block4{:
									  :}
							|
								block4 {:
									:}
							;

block4::=
								procAndFuncDeclaration SEMICOLON block5{:
									  :}
							|
								block5 {:
									:}
							;

block5::=
								BEGIN statementList END{:
									  :}
							;


labelDeclaration::=
								label INTEGER  {:
									:}
							|
								labelDeclaration COMMA INTEGER  {:
									:}
							;


constantDeclaration::=
							   CONST ID EQUALS constant  {:
									:}
							|
							   constantDeclaration SEMICOLON  ID EQUALS constant  {:
									:}
							;


typeDeclaration::=
							   type  ID EQUALS type  {:
									:}
							|
							   typeDeclaration SEMICOLON  ID EQUALS type  {:
									:}
							;


variableDeclaration::=
							   VAR variableidList COLON type {:

									:}
							|
							   variableDeclaration SEMICOLON variableidList COLON type  {:
									:}
							;

variableidList::=
							   ID  {:
									:}
							|
							   variableidList COMMA  ID  {:
									:}
							;

constant::=
								INTEGER {:
									:}
							|
								STRING{:
									:}
							|
								constid  {:
									:}
							;


type::=
								simpleType  {:
									:}
							|
								structuredType  {:
									:}
							|
								XOR typeid  {:
									:}
							;


simpleType::=
							   LEFT_PAR  identifierList RIGHT_PAR  {:
									:}
							|
							 /*  constant ... constant  {:
									:}
									| */
							   typeid {:
									:}
							;


structuredType::=
								ARRAY LEFT_BRACKET indexList RIGHT_BRACKET OF type  {:
									:}
							|
								RECORD fieldList END  {:
									:}
							|
								SET OF simpleType  {:
									:}
							|
								FILE OF type  {:
									:}
							|
								PACKED structuredType  {:
									:}
							;


indexList::=
								simpleType  {:
									:}
							|
								indexList COMMA simpleType  {:
									:}
							;


fieldList::=
								fixedPart  {:
									:}
							|
								fixedPart SEMICOLON variantPart {:
									:}
							|
								variantPart {:
									:}
							;


fixedPart::=
								recordField {:
									:}
							|
								fixedPart SEMICOLON recordField {:
									:}
							;


recordField::=
								empty {:
									RESULT = null;
									:}
							|
								fieldidList COLON type   {:
									:}
							;


fieldidList::=
								ID  {:
									:}
							|
								fieldidList COMMA  ID  {:
									:}
							;


variantPart::=
								CASE tagField OF variantList {:
									:}
							;


tagField::=
								typeid  {:
									:}
							|
								ID COLON typeid  {:
									:}
							;


variantList::=
								variant {:
									:}
							|
								variantList SEMICOLON variant {:
									:}
							;


variant::=
								empty {:
									RESULT = null;
									:}
							|
								caseLabelList COLON LEFT_PAR fieldList RIGHT_PAR  {:
									:}
							;


caseLabelList::=
								constant  {:
									:}
							|
								caseLabelList COMMA constant  {:
									:}
							;


procAndFuncDeclaration::=
								procOrFunc  {:
									:}
							|
								procAndFuncDeclaration SEMICOLON procOrFunc {:
									:}
							;


procOrFunc::=
								PROCEDURE ID parameters blockOrForward {:
									:}
							|
								FUNCTION ID parameters COLON typeid blockOrForward {:
									:}
							;


blockOrForward::=
								SEMICOLON block{:
									:}
							|
								SEMICOLON FORWARD  {:
									:}
							;


parameters::=
								LEFT_PAR formalParameterList RIGHT_PAR{:
									:}
							;


formalParameterList::=
								formalParameterSection  {:
									:}
							|
								formalParameterList SEMICOLON formalParameterSection  {:
									:}
							;


formalParameterSection::=
								parameteridList COLON typeid {:
									:}
							|
								VAR parameteridList COLON typeid  {:
									:}
							|
								PROCEDURE ID parameters {:
									:}
							|
								FUNCTION ID parameters COLON typeid {:
									:}
							;


parameteridList::=
								ID  {:
									:}
							|
								parameteridList COMMA ID  {:
									:}
							;


statementList::=
								statement  {:
										:}
							|
								statementList SEMICOLON statement  {:
									:}
							;


statement::=
								IF expression THEN statement ELSE statement  {:
									:}
							|
								procid LEFT_PAR expressionList RIGHT_PAR{:
									:}
							|
								REPEAT statementList UNTIL expression {:
									:}
							|
								FOR varid ASIGN forList DO statement  {:
									:}
							|
								WITH recordVariableList DO statement  {:
									:}
							|
								CASE expression OF caseList END {:
									:}
							|
								WHILE expression DO statement  {:
									:}
							|
								IF expression THEN statement {:
									:}
							|
								variable ASIGN expression  {:
									:}
							|
								BEGIN statementList END  {:
									:}
							|
								label COLON statement  {:
									:}
							|
								procid  {:
									:}
							|
								empty  {:
									RESULT = null;
									:}
							;


variable::=
								ID LEFT_BRACKET subscriptList RIGHT_BRACKET  {:
									:}
							|
								ID DOT fieldid  {:
									:}
							|
								ID XOR {:
									:}
							;


subscriptList::=
								expression  {:
									:}
							|
								subscriptList COMMA expression  {:
									:}
							;


caseList::=
								caseLabelList COLON statement  {:
									:}
							|
								caseList SEMICOLON caseLabelList COLON statement  {:
									:}
							;


forList::=
								expression TO expression  {:
									:}
							|
								expression DOWNTO expression  {:
									:}
							;


expressionList::=
								expression  {:
									:}
							|
								expressionList COMMA expression  {:
									:}
							;


label::=
								INTEGER{:
									:}
							;


recordVariableList::=
								variable  {:
									:}
							|
								recordVariableList COMMA variable  {:
									:}
							;


expression::=
								expression relationalOp additiveExpression {:
									:}
							|
								additiveExpression  {:
									:}
							|
								INT_CONST {:
									:}
							|
								error {:
									System.out.println("expression error");
									:}
							;


relationalOp::=
								LESS_THAN  {:
									:}
							|
								LESS_EQUAL {:
									:}
							|
								EQUALS {:
									:}
							|
								NOT_EQUAL {:
									:}
							|
								GREATER_EQUALS {:
									:}
							|
								GREATER_THAN {:
										:}
							;


additiveExpression::=
								additiveExpression additiveOp multiplicativeExpression {:
									:}
							|
								multiplicativeExpression  {:
									:}
							;


additiveOp::=
								PLUS {:
									:}
						   |
								MINUS {:
									:}
						   |
								OR {:
									:}
							;


multiplicativeExpression::=
								multiplicativeExpression multiplicativeOp unaryExpression {:
									:}
							|
								unaryExpression  {:
									:}
							;


multiplicativeOp::=
								PRODUCT {:
									:}
							|
								DIVIDE {:
									:}
							|
								DIV  {:
									:}
							|
								MOD {:
									:}
							|
								AND
							|
								IN {:
									:}
							;


unaryExpression::=
								unaryOp unaryExpression  {:
									:}
							|
								primaryExpression  {:
									:}
							;


unaryOp::=
								PLUS {:
									:}
							|
								MINUS {:
									:}
							|
								NOT {:
									:}
							;


primaryExpression::=
								typeid LEFT_PAR expressionList RIGHT_PAR {:
									:}
							|
								LEFT_BRACKET elementList RIGHT_BRACKET {:
									:}
							|
								LEFT_PAR expression RIGHT_PAR  {:
									:}
							|
								NIL  {:
									:}
							|
								INTEGER  {:
									:}
							|
								STRING  {:
									:}
							|
								variable  {:
									:}
							;


elementList::=
								element  {:
									:}
							|
								elementList COMMA element  {:
									:}
							;


element::=
								expression  {:
									:}
							|
								element expression  {:
									:}
							;


constid::=
								ID  {:
									:}
							;


typeid::=
								ID  {:
									:}
							;


procid::=
								ID  {:
									:}
							;


fieldid::=
								ID   {:
									:}
							;


varid::=
								ID  {:
									:}
							;


empty::=
							;